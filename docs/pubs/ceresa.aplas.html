<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="author" content="Martin Ceresa">
        <meta name="robots" content="index, follow">
        <meta name="Description" content="Personal and Research page">
        <title>Martin - Declarative Stream Runtime Verification (hLola)</title>
        <link rel="stylesheet" href="../css/pico.min.css" />
    </head>
    <body>
        <header class="container">
            <nav>
                <ul>
                    <hgroup>
                        <h2><a href="../">Martin Ceresa</a></h2>
                        martin[dot]ceresa[at]imdea[dot]org<br />
                        <a href="https://martinceresa.t.me">Telegram.me</a>
                    </hgroup>
                    </ul>
               <ul>
                       <!-- <button onclick="window.location.href='/pubs'">Publications</button> -->
                   <li><a href="../pubs/" role="button" class="secondary">Publications</a></li>
                       <!-- <button onclick="window.location.href='#repath'">Research</button> -->
                   <li><a href="../index.html#repath" role="button" class="secondary">Research Path</a></li>
               </ul>
            </nav>
        </header>
        <main class="container">
            <article>
  <header>
    <hgroup>
      <h2>Declarative Stream Runtime Verification (hLola)</h2>
      Martín Ceresa and Felipe Gorostiaga and César Sánchez<br />Asian Programming Languages and Systems(2020)
    </hgroup>
  </header>
  <h3>Abstract</h3>
  <p>Stream Runtime Verification (SRV) is a formal dynamic analysis technique that
generalizes runtime verification algorithms from temporal logics like LTL to
stream monitoring, allowing the computation of richer verdicts than Booleans
(quantitative values or even arbitrary data). The core of SRV algorithms is a
clean separation between temporal dependencies and data computations. In spite
of this theoretical separation previous engines include ad-hoc implementations
of just a few data types, requiring complex changes in the tools to incorporate
new data types.</p>
<p>In this paper we present a solution as a Haskell embedded domain specific
language that is easily extensible to arbitrary data types. The solution is
enabled by a technique, which we call lift deep embedding, that consists in
borrowing general Haskell types and embedding them transparently into an eDSL.
This allows for example the use of higher-order functions to implement static
stream parametrization. We describe the Haskell implementation called HLOLA and
illustrate simple extensions implemented using libraries, which would require
long and error-prone additions in other ad-hoc SRV formalisms.</p>
  <footer>
   <a href="https://doi.org/10.1007/978-3-030-64437-6_2">Cite</a>
  
  </footer>
</article>

        </main>
        <footer class="container">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
            and styles from
            <a href="https://picocss.com">Pico</a>
        </footer>
    </body>
</html>
